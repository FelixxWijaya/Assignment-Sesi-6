# -*- coding: utf-8 -*-
"""2702360403-FelixWijaya-Euler_method

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iRfObZX9nDT6P0-mbNFrL5PX8idj2KX-
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt

plt.style.use('seaborn-poster')
# %matplotlib inline
 # Define parameters
f = lambda t, s: np.exp(-t) # ODE
h = 0.1 # Step size
t = np.arange(0, 1 + h, h) # Numerical grid
s0 = -1 # Initial Condition
 # Explicit Euler Method
s = np.zeros(len(t))
s[0] = s0
for i in range(0, len(t) - 1):
    s[i + 1] = s[i] + h*f(t[i], s[i])

plt.figure(figsize = (12, 8))
plt.plot(t, s, 'bo--', label='Approximate')
plt.plot(t, -np.exp(-t), 'g', label='Exact')
plt.title('Approximate and Exact Solution \
for Simple ODE')
plt.xlabel('t')
plt.ylabel('f(t)')
plt.grid()
plt.legend(loc='lower right')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Fungsi turunan
def dy_dx(y):
    return np.sin(y)

# Metode Euler untuk menyelesaikan persamaan diferensial
def euler_method(dy_dx, y0, x_range, h):
    x_values = np.arange(x_range[0], x_range[1] + h, h)
    y_values = np.zeros(len(x_values))
    y_values[0] = y0

    for i in range(1, len(x_values)):
        y_values[i] = y_values[i-1] + h * dy_dx(y_values[i-1])

    return x_values, y_values

# Kondisi awal
y0 = 1
x_range = (0, 0.5)
h = 0.1

# Hitung nilai y untuk setiap x
x_values, y_values = euler_method(dy_dx, y0, x_range, h)

# Buat grafik
plt.plot(x_values, y_values, marker='o')
plt.xlabel('x')
plt.ylabel('y')
plt.title("Grafik dari y' = sin(y) dengan y(0) = 1")
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Fungsi turunan
def dy_dx(y):
    return np.sin(y)

# Metode Euler untuk menyelesaikan persamaan diferensial
def euler_method(dy_dx, y0, x_range, h):
    x_values = np.arange(x_range[0], x_range[1] + h, h)
    y_values = np.zeros(len(x_values))
    y_values[0] = y0

    for i in range(1, len(x_values)):
        y_values[i] = y_values[i-1] + h * dy_dx(y_values[i-1])

    return x_values, y_values

# Kondisi awal
y0 = 1
x_range = (0, 0.5)
h = 0.1

# Hitung nilai y untuk setiap x
x_values, y_values = euler_method(dy_dx, y0, x_range, h)

# Buat grafik
plt.plot(x_values, y_values, marker='o')
plt.xlabel('x')
plt.ylabel('y')
plt.title("Grafik dari y' = sin(y) dengan y(0) = 1")
plt.grid(True)
plt.show()

h = 0.01 # Step size
t = np.arange(0, 1 + h, h) # Numerical grid
s0 = -1 # Initial Condition

# Explicit Euler Method
s = np.zeros(len(t))
s[0] = s0

for i in range(0, len(t) - 1):
    s[i + 1] = s[i] + h*f(t[i], s[i])

plt.figure(figsize = (12, 8))
plt.plot(t, s, 'b--', label='Approximate')
plt.plot(t, -np.exp(-t), 'g', label='Exact')
plt.title('Approximate and Exact Solution \
for Simple ODE')
plt.xlabel('t')
plt.ylabel('f(t)')
plt.grid()
plt.legend(loc='lower right')
plt.show()